# Code Conventions

Path: `./ctx/docs/code/conventions.md`

## Назначение

Документ фиксирует инженерные инварианты кодового слоя.
Он определяет допустимые языковые средства, правила организации модулей, модель внедрения зависимостей, требования к декларациям типов и общие ограничения реализации.

Документ не описывает архитектуру, продукт, композицию выполнения или поведение агента.

---

## 1. Язык и модульная модель

- Production-код пишется на JavaScript (ESM).
- Используются `.mjs`-модули.
- TypeScript в production-коде запрещён.
- CommonJS допускается только внутри сторонних зависимостей.
- Все project-модули экспортируют значение через `default`-экспорт, если модуль представляет класс DI-графа.

---

## 2. Структура и namespace

- Production-код размещается в `src/`.
- Тесты размещаются в `test/`.
- Namespace root определяется в composition root.
- В production-графе используется один namespace root.
- Namespace не расширяется динамически во время выполнения.

---

## 3. Dependency Injection

- Единственный механизм связывания зависимостей — `@teqfw/di`.
- Все зависимости внедряются через конструктор.
- Классы не взаимодействуют с контейнером напрямую.
- Контейнер не передаётся в бизнес-классы.

Запрещено:

- использовать container как service locator;
- вызывать `container.get()` вне composition root и тестов;
- создавать DI-компоненты через `new` вручную.

### 3.1 Dependency ID

Используются:

- `$` — singleton;
- `$$` — новый экземпляр;
- `node:` — platform и node_modules зависимости.

`.export` не используется.

---

## 4. Composition Root

- В системе существует ровно один production composition root.
- `container.register` запрещён в production-коде.
- Composition root отвечает только за:
  - создание контейнера;
  - настройку namespace;
  - получение entrypoint-компонента;
  - завершение процесса.

---

## 5. Работа с Platform API

- Platform API подключается через DI с использованием `node:` Dependency ID.
- Статические импорты platform API внутри production-кода запрещены.
- Прямое обращение к `process.env` допускается только в специализированном конфигурационном компоненте.

---

## 6. Конфигурация

- Конфигурация представляется immutable-объектом.
- Значения конфигурации не мутируются в runtime.
- Загрузка `.env` выполняется без сторонних библиотек.
- Конфигурационный компонент изолирует остальной код от `process.env`.

---

## 7. Асинхронная модель

- Базовая модель — `async/await`.
- Блокирующие операции запрещены.
- Смешивание callback- и promise-моделей допускается только при интеграции с внешними API.

---

## 8. Состояние и мутабельность

- Пользовательское глобальное состояние запрещено.
- Допускается только platform-state.
- Изменяемое состояние должно быть локализовано.
- Рекомендуется использовать immutable-объекты для результатов вычислений.

---

## 9. Обработка ошибок

- Исключения допускаются в нижних слоях.
- Централизация обработки выполняется в верхнем слое исполнения.
- Публичные entrypoint-методы не должны выбрасывать необработанные исключения.
- Преобразование ошибок в exit-code выполняется централизованно.

---

## 10. Логирование

- Используется централизованный Logger через DI.
- `console.*` запрещён.
- Логирование не влияет на поведение программы.
- Секреты не должны попадать в лог.

---

## 11. Storage

Кодовый слой обязан обеспечивать:

- атомарность записи;
- отсутствие частичной фиксации;
- запрет скрытой мутации сохранённых данных.

Конкретная модель хранения определяется архитектурным уровнем.

---

## 12. Тестирование

Поддерживаются два режима:

- unit;
- dev.

### 12.1 Unit

- Строгая DI-изоляция.
- Запрещены реальные side effects.
- Каждый тест создаёт собственный контейнер.
- Обязательно `enableTestMode()`.

### 12.2 Dev

- Допускаются реальные интеграционные вызовы.
- Не создают альтернативного production-режима.
- Каждый тест создаёт собственный контейнер.

Используется `node:test`. Сторонние тестовые фреймворки не применяются.

---

## 13. Декларации типов (`types.d.ts`)

Проект использует декларационный файл `types.d.ts` для описания DI-классов.

### 13.1 Нормативная форма

```ts
declare global {
  type Namespace_Component = InstanceType<typeof import("./src/Component.mjs").default>
}

export {};
```

Требования:

- используется `declare global`;
- применяется `type`, а не `interface`;
- путь указывается относительно корня проекта;
- используется `.mjs`;
- берётся `default`-экспорт;
- файл завершается `export {};`.

### 13.2 Обязательность

- Каждый новый production-класс должен быть отражён в `types.d.ts`.
- Имя типа должно совпадать с DI-namespace без суффиксов `$` или `$$`.
- Отсутствие декларации считается дефектом кодового слоя.

---

## 14. Запрещено

- TypeScript в production-коде;
- `eval`;
- альтернативные DI-механизмы;
- второй production composition root;
- прямое использование container в бизнес-классах;
- использование `console.*`.
